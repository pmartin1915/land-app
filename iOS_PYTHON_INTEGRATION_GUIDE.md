# iOS-Python Integration Guide ## Alabama Auction Watcher Cross-Platform Development **Project**: Alabama Auction Watcher Phase 2A **Integration Date**: September 19, 2025 **Status**: Production-Ready Cross-Platform Foundation Established **Scope**: Comprehensive guide for maintaining iOS-Python algorithm consistency --- ## Algorithm Compatibility Matrix ### Validated Algorithms (iOS ↔ Python) | Algorithm | Python Result | iOS Swift Result | Status | Tolerance | |-----------|---------------|------------------|---------|-----------| | **Investment Score** (5000.0, 3.0, 6.0, 0.8) | 52.8 | 52.8 | EXACT | ±0.1 | | **Investment Score** (10000.0, 1.0, 0.0, 1.2) | 23.3 | 23.7 | PASS | ±0.5 | | **Water Detection** "creek frontage" | 3.0 | 3.0 | EXACT | ±0.0 | | **Water Detection** "pond and stream" | 6.0 | 6.0 | EXACT | ±0.0 | | **County Validation** All 67 counties | 100% | 100% | EXACT | N/A | | **Cost Calculation** $10,000 → $10,635 | $10,635.00 | $10,635.00 | EXACT | ±$0.01 | ### Data Structure Mapping #### Property Entity Mapping ```python # Python (scripts/utils.py + parser.py) property_data = { 'parcel_id': str, # Primary identifier 'amount': float, # Bid amount 'acreage': float, # Property acreage 'price_per_acre': float, # Calculated: amount / acreage 'water_score': float, # Calculated: 0.0-15.0+ range 'investment_score': float, # Calculated: 0.0-100.0 range 'estimated_all_in_cost': float, # Calculated: amount + fees 'assessed_value': float, # From CSV data 'assessed_value_ratio': float, # Calculated: amount / assessed_value 'description': str, # Property legal description 'county': str, # Alabama county name 'owner_name': str, # Property owner 'year_sold': str, # Sale year 'rank': int, # Sorted rank by investment score 'created_at': datetime, # Record creation 'updated_at': datetime # Last modification } ``` ```swift // iOS Core Data Entity (Property) @objc(Property) public class Property: NSManagedObject { @NSManaged public var parcelId: String? @NSManaged public var amount: Double @NSManaged public var acreage: Double @NSManaged public var pricePerAcre: Double @NSManaged public var waterScore: Double @NSManaged public var investmentScore: Double @NSManaged public var estimatedAllInCost: Double @NSManaged public var assessedValue: Double @NSManaged public var assessedValueRatio: Double @NSManaged public var propertyDescription: String? @NSManaged public var county: String? @NSManaged public var ownerName: String? @NSManaged public var yearSold: String? @NSManaged public var rank: Int32 @NSManaged public var createdAt: Date? @NSManaged public var updatedAt: Date? } ``` --- ## API Specification ### REST API Endpoints #### 1. Property Operations ```python # FastAPI Backend Implementation Required @app.get("/api/v1/properties") async def get_properties( county: Optional[str] = None, min_price: Optional[float] = None, max_price: Optional[float] = None, min_acreage: Optional[float] = None, max_acreage: Optional[float] = None, water_features: Optional[bool] = None, min_investment_score: Optional[float] = None, limit: int = 100, offset: int = 0 ) -> PropertyListResponse: """ Filter and return properties matching criteria. MUST use exact same filtering logic as iOS PropertyListViewModel. """ @app.get("/api/v1/properties/{property_id}") async def get_property(property_id: str) -> PropertyResponse: """Get specific property with all calculated metrics.""" @app.post("/api/v1/properties") async def create_property(property: PropertyCreate) -> PropertyResponse: """ Create new property and calculate all metrics using EXACT Python algorithms. CRITICAL: Must use same utils.py functions for calculations. """ @app.put("/api/v1/properties/{property_id}") async def update_property(property_id: str, property: PropertyUpdate) -> PropertyResponse: """ Update property and recalculate metrics if necessary. CRITICAL: Maintain algorithm consistency. """ ``` #### 2. Synchronization Protocol ```python @app.post("/api/v1/sync/delta") async def delta_sync(sync_request: DeltaSyncRequest) -> DeltaSyncResponse: """ Perform incremental sync based on timestamps. Returns only changes since last_sync_timestamp. """ # Delta Sync Request/Response Models class DeltaSyncRequest(BaseModel): device_id: str last_sync_timestamp: datetime changes: List[PropertyChange] class DeltaSyncResponse(BaseModel): server_changes: List[PropertyChange] conflicts: List[SyncConflict] new_sync_timestamp: datetime sync_status: str # "success", "partial", "conflict" class PropertyChange(BaseModel): property_id: str operation: str # "create", "update", "delete" data: Optional[Dict[str, Any]] timestamp: datetime device_id: str ``` #### 3. CSV Import Pipeline ```python @app.post("/api/v1/import/csv") async def import_csv( file: UploadFile, county_override: Optional[str] = None, calculate_metrics: bool = True ) -> ImportJobResponse: """ Import CSV file and process using existing AuctionParser. CRITICAL: Must use exact same parser.py logic as desktop app. """ class ImportJobResponse(BaseModel): job_id: str status: str # "queued", "processing", "completed", "failed" total_rows: int processed_rows: int errors: List[str] created_at: datetime ``` --- ## iOS Implementation Specifications ### NetworkManager Implementation ```swift class NetworkManager: ObservableObject { private let baseURL = URL(string: "https://api.alabamaauctionwatcher.com/api/v1")! // CRITICAL: Ensure request/response models match API exactly struct PropertyResponse: Codable { let parcelId: String? let amount: Double let acreage: Double let pricePerAcre: Double let waterScore: Double let investmentScore: Double let estimatedAllInCost: Double let assessedValue: Double let assessedValueRatio: Double let description: String? let county: String? let ownerName: String? let yearSold: String? let rank: Int? let createdAt: String let updatedAt: String } func fetchProperties(filters: PropertyFilters) async throws -> [PropertyResponse] { var components = URLComponents(url: baseURL.appendingPathComponent("properties"), resolvingAgainstBaseURL: false)! // Build query parameters matching API filters var queryItems: [URLQueryItem] = [] if let county = filters.county { queryItems.append(URLQueryItem(name: "county", value: county)) } if filters.minPrice > 0 { queryItems.append(URLQueryItem(name: "min_price", value: "\(filters.minPrice)")) } if filters.maxPrice < Double.greatestFiniteMagnitude { queryItems.append(URLQueryItem(name: "max_price", value: "\(filters.maxPrice)")) } // ... add all filter parameters components.queryItems = queryItems let (data, _) = try await URLSession.shared.data(from: components.url!) return try JSONDecoder().decode([PropertyResponse].self, from: data) } } ``` ### Core Data Sync Integration ```swift extension Property { func updateFromAPI(_ apiProperty: NetworkManager.PropertyResponse) { // Map API response to Core Data entity // CRITICAL: Ensure exact field mapping parcelId = apiProperty.parcelId amount = apiProperty.amount acreage = apiProperty.acreage pricePerAcre = apiProperty.pricePerAcre waterScore = apiProperty.waterScore investmentScore = apiProperty.investmentScore estimatedAllInCost = apiProperty.estimatedAllInCost assessedValue = apiProperty.assessedValue assessedValueRatio = apiProperty.assessedValueRatio propertyDescription = apiProperty.description county = apiProperty.county ownerName = apiProperty.ownerName yearSold = apiProperty.yearSold rank = Int32(apiProperty.rank ?? 0) // Parse dates let formatter = ISO8601DateFormatter() updatedAt = formatter.date(from: apiProperty.updatedAt) } func toAPIModel() -> NetworkManager.PropertyCreate { return NetworkManager.PropertyCreate( parcelId: parcelId, amount: amount, acreage: acreage, description: propertyDescription, county: county, ownerName: ownerName, yearSold: yearSold, assessedValue: assessedValue // Note: Calculated fields will be computed by backend ) } } ``` --- ## Algorithm Validation Requirements ### Python Backend Validation ```python # Backend MUST use exact same algorithms from utils.py from scripts.utils import ( calculate_investment_score, calculate_water_score, calculate_estimated_all_in_cost, calculate_price_per_acre ) from config.settings import INVESTMENT_SCORE_WEIGHTS def calculate_property_metrics(property_data: dict) -> dict: """ Calculate all property metrics using exact Python algorithms. CRITICAL: This function must produce identical results to iOS calculations. """ # Water score calculation water_score = calculate_water_score(property_data.get('description', '')) # Price per acre calculation price_per_acre = 0.0 if property_data.get('acreage', 0) > 0: price_per_acre = property_data['amount'] / property_data['acreage'] # Assessed value ratio assessed_value_ratio = 0.0 if property_data.get('assessed_value', 0) > 0: assessed_value_ratio = property_data['amount'] / property_data['assessed_value'] # Investment score calculation investment_score = calculate_investment_score( price_per_acre=price_per_acre, acreage=property_data.get('acreage', 0), water_score=water_score, assessed_value_ratio=assessed_value_ratio, weights=INVESTMENT_SCORE_WEIGHTS ) # All-in cost calculation estimated_all_in_cost = calculate_estimated_all_in_cost(property_data['amount']) return { 'water_score': water_score, 'price_per_acre': price_per_acre, 'assessed_value_ratio': assessed_value_ratio, 'investment_score': investment_score, 'estimated_all_in_cost': estimated_all_in_cost } ``` ### iOS Validation Requirement ```swift // iOS MUST validate results against Python backend class AlgorithmValidator { static func validateAgainstBackend(_ property: Property) async throws -> ValidationResult { // Send property data to backend for calculation let backendCalculation = try await NetworkManager.shared.calculateMetrics( amount: property.amount, acreage: property.acreage, description: property.propertyDescription ?? "", assessedValue: property.assessedValue ) // Compare iOS calculations with backend let investmentScoreDiff = abs(property.investmentScore - backendCalculation.investmentScore) let waterScoreDiff = abs(property.waterScore - backendCalculation.waterScore) // Validation thresholds let isInvestmentScoreValid = investmentScoreDiff < 0.5 let isWaterScoreValid = waterScoreDiff < 0.1 return ValidationResult( isValid: isInvestmentScoreValid && isWaterScoreValid, investmentScoreDifference: investmentScoreDiff, waterScoreDifference: waterScoreDiff ) } } ``` --- ## Data Synchronization Protocol ### Conflict Resolution Strategy ```swift enum SyncConflictResolution { case useLocal // Local changes win case useRemote // Remote changes win case merge // Intelligent merge case askUser // Present choice to user } class SyncConflictResolver { func resolveConflict(_ conflict: SyncConflict) -> SyncConflictResolution { // Last-write-wins strategy for most fields if conflict.localTimestamp > conflict.remoteTimestamp { return .useLocal } else if conflict.remoteTimestamp > conflict.localTimestamp { return .useRemote } // For critical fields, ask user if conflict.affectsCalculatedFields { return .askUser } return .useRemote // Default to remote when uncertain } } ``` ### Background Sync Implementation ```swift class BackgroundSyncManager { private let syncInterval: TimeInterval = 15 * 60 // 15 minutes func performBackgroundSync() async { do { // Get changes since last sync let lastSyncDate = UserDefaults.standard.object(forKey: "lastSyncDate") as? Date ?? Date.distantPast // Upload local changes let localChanges = try await getLocalChangesSince(lastSyncDate) if !localChanges.isEmpty { try await NetworkManager.shared.uploadChanges(localChanges) } // Download remote changes let remoteChanges = try await NetworkManager.shared.getDeltaSync(since: lastSyncDate) // Apply remote changes to Core Data try await applyRemoteChanges(remoteChanges) // Sync with CloudKit try await CloudKitSyncCoordinator.shared.syncWithCloudKit() // Update last sync timestamp UserDefaults.standard.set(Date(), forKey: "lastSyncDate") } catch { // Log error for AI analysis print("Background sync failed: \(error)") } } } ``` --- ## Performance Requirements ### Backend Performance Targets - **Property list API**: < 500ms response time for 1,000 properties - **Single property API**: < 100ms response time - **CSV import**: < 60 seconds for 10,000 properties - **Delta sync**: < 30 seconds for 1,000 property changes - **Concurrent users**: Support 100+ simultaneous API requests ### iOS Performance Targets - **App launch**: < 3 seconds on iPhone 12+ - **Property list load**: < 2 seconds for 10,000 properties - **Search/filter**: < 500ms for real-time updates - **Background sync**: < 30 seconds for 1,000 property delta - **Memory usage**: < 100MB for 10,000 properties ### Optimization Strategies ```python # Backend optimizations from fastapi import Depends from sqlalchemy.orm import joinedload @app.get("/api/v1/properties") async def get_properties( db: Session = Depends(get_db), filters: PropertyFilters = Depends() ): # Use database indexes for filtering query = db.query(Property) if filters.county: query = query.filter(Property.county == filters.county) if filters.min_investment_score: query = query.filter(Property.investment_score >= filters.min_investment_score) # Efficient pagination properties = query.offset(filters.offset).limit(filters.limit).all() return properties ``` ```swift // iOS optimizations extension PropertyListViewModel { func loadPropertiesOptimized() { let request: NSFetchRequest<Property> = Property.fetchRequest() // Batch fetching request.fetchBatchSize = 100 // Only fetch needed properties request.includesPropertyValues = true request.includesSubentities = false // Use predicates for filtering var predicates: [NSPredicate] = [] if let county = filterOptions.selectedCounty, county != "All" { predicates.append(NSPredicate(format: "county == %@", county)) } if filterOptions.minimumInvestmentScore > 0 { predicates.append(NSPredicate(format: "investmentScore >= %f", filterOptions.minimumInvestmentScore)) } request.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: predicates) // Efficient sorting request.sortDescriptors = [NSSortDescriptor(keyPath: \Property.investmentScore, ascending: false)] do { properties = try persistenceController.container.viewContext.fetch(request) } catch { print("Fetch error: \(error)") } } } ``` --- ## Testing & Validation Protocol ### Integration Test Requirements ```swift // Required integration tests for Phase 2A Week 3-4 class Phase2AIntegrationTests: XCTestCase { func testAlgorithmConsistencyAcrossPlatforms() async throws { // Create test property data let testProperty = createTestPropertyData() // Calculate metrics in iOS let iosMetrics = calculateMetricsIOS(testProperty) // Send to backend for calculation let backendMetrics = try await NetworkManager.shared.calculateMetrics(testProperty) // Validate consistency XCTAssertEqual(iosMetrics.investmentScore, backendMetrics.investmentScore, accuracy: 0.5) XCTAssertEqual(iosMetrics.waterScore, backendMetrics.waterScore, accuracy: 0.1) } func testFullSyncWorkflow() async throws { // Test complete sync workflow // 1. Create properties locally // 2. Sync to backend // 3. Sync to CloudKit // 4. Verify consistency across all platforms } func testLargeDatasetPerformance() async throws { // Test with 10,000+ properties // Validate memory usage stays under 100MB // Validate sync completes within performance targets } } ``` ### Validation Checklist - [ ] All algorithms produce identical results (±acceptable tolerance) - [ ] API request/response models match exactly - [ ] Core Data schema compatible with backend database - [ ] Sync protocol handles conflicts correctly - [ ] Performance targets met under load - [ ] Error handling includes recovery instructions - [ ] Background sync works reliably - [ ] CloudKit integration functional across devices --- ## Troubleshooting Guide ### Common Integration Issues **Algorithm Mismatch** ``` Symptom: iOS and Python produce different investment scores Diagnosis: Check weight validation, keyword arrays, mathematical precision Solution: Run algorithm validation tests, verify exact formula implementation ``` **Sync Failures** ``` Symptom: Properties not syncing between devices Diagnosis: Check network connectivity, authentication, API endpoints Solution: Verify API authentication, check CloudKit permissions, validate data models ``` **Performance Issues** ``` Symptom: App slow with large datasets Diagnosis: Memory usage, Core Data fetch efficiency, API response times Solution: Implement batching, optimize fetch requests, add database indexes ``` **Data Consistency Issues** ``` Symptom: Properties have different values across platforms Diagnosis: Sync timing, conflict resolution, data validation Solution: Check sync timestamps, validate conflict resolution logic, ensure data integrity ``` --- This integration guide provides the technical foundation for seamless iOS-Python integration while maintaining the exact algorithm compatibility established in Phase 2A Week 1-2. Follow these specifications precisely to ensure successful cross-platform functionality.