# Phase 2A Week 3-4: Data Synchronization & API Integration - Detailed Roadmap ## Executive Summary **Objective**: Connect the completed iOS mobile application foundation with the Python backend to enable real-time data synchronization, CloudKit integration, and CSV import capabilities. **Timeline**: 2 weeks (Week 3-4 of Phase 2A) **Prerequisites**: Phase 2A Week 1-2 completed with iOS foundation and algorithm validation **Deliverable**: Fully integrated iOS-Python system with offline/online synchronization --- ## Week 3: REST API Development & Backend Integration ### Day 1-2: FastAPI Backend Development **Objective**: Create production-ready REST API endpoints for iOS integration #### Task 3.1: FastAPI Project Setup ```bash # Project structure to create backend_api/ ├── main.py # FastAPI application entry point ├── models/ # Pydantic models │ ├── property.py # Property data models │ ├── county.py # County models │ └── sync.py # Sync protocol models ├── routers/ # API route handlers │ ├── properties.py # Property CRUD operations │ ├── counties.py # County endpoints │ └── sync.py # Synchronization endpoints ├── services/ # Business logic layer │ ├── property_service.py # Property operations │ └── sync_service.py # Sync logic └── database/ # Database layer ├── connection.py # DB connection management └── models.py # SQLAlchemy models ``` **API Endpoints to Implement:** ```python # Core Property Endpoints GET /api/v1/properties # List properties with filtering GET /api/v1/properties/{id} # Get specific property POST /api/v1/properties # Create new property PUT /api/v1/properties/{id} # Update property DELETE /api/v1/properties/{id} # Delete property # County Endpoints GET /api/v1/counties # List all 67 Alabama counties GET /api/v1/counties/{code} # Get specific county info # Synchronization Endpoints POST /api/v1/sync/delta # Delta sync for incremental updates POST /api/v1/sync/full # Full sync for initial load GET /api/v1/sync/status # Get sync status and timestamps # Data Import Endpoints POST /api/v1/import/csv # CSV file upload and processing GET /api/v1/import/status/{job_id} # Import job status GET /api/v1/import/history # Import history ``` #### Task 3.2: Database Integration ```python # SQLAlchemy models matching Core Data schema exactly class Property(Base): __tablename__ = "properties" id = Column(String, primary_key=True) parcel_id = Column(String, nullable=False, index=True) amount = Column(Float, nullable=False) acreage = Column(Float, nullable=True) price_per_acre = Column(Float, nullable=True) water_score = Column(Float, default=0.0) investment_score = Column(Float, nullable=True) estimated_all_in_cost = Column(Float, nullable=True) assessed_value = Column(Float, nullable=True) assessed_value_ratio = Column(Float, nullable=True) description = Column(Text, nullable=True) county = Column(String, nullable=True) owner_name = Column(String, nullable=True) year_sold = Column(String, nullable=True) rank = Column(Integer, nullable=True) created_at = Column(DateTime, default=datetime.utcnow) updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow) ``` #### Task 3.3: Authentication & Security ```python # JWT-based authentication for iOS app from fastapi_users import FastAPIUsers from fastapi_users.authentication import JWTAuthentication # Rate limiting for API protection from slowapi import Limiter, _rate_limit_exceeded_handler from slowapi.util import get_remote_address limiter = Limiter(key_func=get_remote_address) @app.get("/api/v1/properties") @limiter.limit("100/minute") async def get_properties(request: Request, ...): # Implementation with rate limiting ``` ### Day 3-4: iOS API Integration **Objective**: Implement iOS networking layer for backend communication #### Task 3.4: NetworkManager Implementation ```swift // Create comprehensive API client class NetworkManager: ObservableObject { private let baseURL = "https://api.alabamaauctionwatcher.com/api/v1" private let session = URLSession.shared // Authentication func authenticate(username: String, password: String) async throws -> AuthResponse // Property operations func fetchProperties(filters: PropertyFilters) async throws -> [Property] func createProperty(_ property: Property) async throws -> Property func updateProperty(_ property: Property) async throws -> Property func deleteProperty(id: String) async throws // Sync operations func performDeltaSync(lastSyncTimestamp: Date) async throws -> SyncResponse func uploadChanges(_ changes: [PropertyChange]) async throws -> SyncResponse // CSV import func importCSV(data: Data, filename: String) async throws -> ImportJobResponse func getImportStatus(jobId: String) async throws -> ImportStatusResponse } ``` #### Task 3.5: Data Models Integration ```swift // Extend Core Data models with API capabilities extension Property { // Convert to API request format func toAPIModel() -> APIProperty { return APIProperty( id: objectID.uriRepresentation().absoluteString, parcelId: parcelId, amount: amount, acreage: acreage, // ... all properties matching backend exactly ) } // Update from API response func updateFromAPI(_ apiProperty: APIProperty) { amount = apiProperty.amount acreage = apiProperty.acreage waterScore = apiProperty.waterScore // ... update all properties } } ``` #### Task 3.6: Sync Conflict Resolution ```swift // Last-write-wins strategy with user notification class SyncConflictResolver { func resolveConflicts(_ conflicts: [SyncConflict]) async -> [SyncResolution] { var resolutions: [SyncResolution] = [] for conflict in conflicts { // Compare timestamps if conflict.localTimestamp > conflict.remoteTimestamp { // Local wins, push to server resolutions.append(.useLocal(conflict)) } else { // Remote wins, update local resolutions.append(.useRemote(conflict)) } } return resolutions } } ``` ### Day 5: Background Sync Implementation **Objective**: Enable automatic background synchronization #### Task 3.7: Background Sync Service ```swift import BackgroundTasks class BackgroundSyncService { static let shared = BackgroundSyncService() private let backgroundTaskIdentifier = "com.alabamaauctionwatcher.sync" func scheduleBackgroundSync() { let request = BGAppRefreshTaskRequest(identifier: backgroundTaskIdentifier) request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // 15 minutes try? BGTaskScheduler.shared.submit(request) } func performBackgroundSync() async { // Perform delta sync with backend // Update Core Data // Sync with CloudKit // Schedule next sync } } ``` --- ## Week 4: CloudKit Integration & Data Import Pipeline ### Day 6-7: CloudKit Schema Configuration **Objective**: Configure CloudKit to match Core Data exactly with multi-device sync #### Task 4.1: CloudKit Schema Setup ```swift // Configure CloudKit container in PersistenceController import CloudKit extension PersistenceController { func configureCloudKit() { // Configure container container.persistentStoreDescriptions.forEach { storeDescription in storeDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey) storeDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey) } // Handle remote changes NotificationCenter.default.addObserver( forName: .NSPersistentStoreRemoteChange, object: container.persistentStoreCoordinator, queue: .main ) { _ in self.handleRemoteChanges() } } } ``` #### Task 4.2: CloudKit Sync Coordination ```swift class CloudKitSyncCoordinator: ObservableObject { @Published var syncStatus: SyncStatus = .idle @Published var lastSyncDate: Date? func syncWithCloudKit() async { syncStatus = .syncing do { // Export local changes to CloudKit try await exportLocalChanges() // Import CloudKit changes to local try await importCloudKitChanges() // Resolve any conflicts try await resolveCloudKitConflicts() lastSyncDate = Date() syncStatus = .completed } catch { syncStatus = .failed(error) } } } ``` ### Day 8-9: CSV Import Pipeline **Objective**: Enable CSV file import with progress tracking and validation #### Task 4.3: CSV Import Service ```swift class CSVImportService: ObservableObject { @Published var importProgress: ImportProgress? @Published var importErrors: [ImportError] = [] func importCSV(from url: URL) async throws { importProgress = ImportProgress(totalRows: 0, processedRows: 0, stage: .reading) // Parse CSV file let csvData = try parseCSVFile(url) importProgress?.totalRows = csvData.count // Validate data let validationErrors = validateCSVData(csvData) if !validationErrors.isEmpty { throw ImportError.validationFailed(validationErrors) } // Process in batches for batch in csvData.chunked(into: 100) { try await processBatch(batch) importProgress?.processedRows += batch.count } // Calculate metrics and update Core Data try await calculateMetricsForImportedProperties() importProgress = nil } private func calculateMetricsForImportedProperties() async throws { // Use ported algorithms to calculate scores let properties = try await fetchNewlyImportedProperties() for property in properties { property.waterScore = WaterFeatureDetector.calculateWaterScore( description: property.propertyDescription ?? "" ) property.pricePerAcre = InvestmentCalculator.calculatePricePerAcre( amount: property.amount, acreage: property.acreage ) property.investmentScore = InvestmentCalculator.calculateInvestmentScore( pricePerAcre: property.pricePerAcre, acreage: property.acreage, waterScore: property.waterScore, assessedValueRatio: property.assessedValueRatio ) } try await saveContext() } } ``` #### Task 4.4: Progress Tracking UI ```swift struct ImportProgressView: View { @ObservedObject var importService: CSVImportService var body: some View { VStack(spacing: 20) { if let progress = importService.importProgress { Text("Importing CSV Data") .font(.headline) ProgressView(value: Double(progress.processedRows), total: Double(progress.totalRows)) Text("\(progress.processedRows) of \(progress.totalRows) rows processed") .font(.caption) .foregroundColor(.secondary) Text("Stage: \(progress.stage.description)") .font(.caption) } if !importService.importErrors.isEmpty { ErrorListView(errors: importService.importErrors) } } } } ``` ### Day 10: Integration Testing & Polish **Objective**: Comprehensive testing and performance validation #### Task 4.5: Integration Test Suite ```swift class IntegrationTests: XCTestCase { func testFullSyncWorkflow() async throws { // Test complete sync between iOS, backend, and CloudKit let properties = try await createTestProperties(count: 1000) // Upload to backend try await NetworkManager.shared.uploadProperties(properties) // Sync with CloudKit try await CloudKitSyncCoordinator.shared.syncWithCloudKit() // Verify data consistency let backendProperties = try await NetworkManager.shared.fetchProperties() XCTAssertEqual(properties.count, backendProperties.count) // Verify algorithms still work correctly for property in backendProperties { let expectedScore = calculateExpectedInvestmentScore(property) XCTAssertEqual(property.investmentScore, expectedScore, accuracy: 0.1) } } func testCSVImportWithLargeDataset() async throws { // Test importing 10,000 property CSV let csvURL = createLargeTestCSV(rows: 10000) let startTime = Date() try await CSVImportService.shared.importCSV(from: csvURL) let duration = Date().timeIntervalSince(startTime) // Should complete in under 60 seconds XCTAssertLessThan(duration, 60.0) // Verify all properties have calculated scores let properties = try await fetchAllProperties() for property in properties { XCTAssertGreaterThan(property.investmentScore, 0) if property.propertyDescription?.contains("creek") == true { XCTAssertGreaterThanOrEqual(property.waterScore, 3.0) } } } } ``` #### Task 4.6: Performance Optimization ```swift // Optimize Core Data performance for large datasets class PerformanceOptimizer { static func optimizeCoreDataForLargeDatasets(_ context: NSManagedObjectContext) { // Batch processing context.stalenessInterval = 0.0 // Memory pressure handling context.automaticallyMergesChangesFromParent = true // Fetch request optimization let request = NSFetchRequest<Property>(entityName: "Property") request.fetchBatchSize = 100 request.includesPropertyValues = false request.includesSubentities = false // Index optimization for search request.predicate = NSPredicate(format: "county = %@", argumentArray: ["Baldwin"]) } static func monitorMemoryUsage() { let memoryInfo = mach_task_basic_info() // Log memory usage for AI monitoring print("Memory usage: \(memoryInfo.resident_size / 1024 / 1024) MB") } } ``` --- ## Success Criteria & Validation ### Technical Metrics - **API Response Time**: < 500ms for property list requests - **Sync Performance**: < 30 seconds for 1,000 property delta sync - **CSV Import Speed**: < 60 seconds for 10,000 property import - **Memory Usage**: < 100MB for 10,000 properties in Core Data - **CloudKit Sync**: < 2 minutes for full device sync ### Functional Requirements - **Two-way sync** between iOS app and Python backend - **Offline functionality** with sync queue when connectivity restored - **Real-time updates** across multiple iOS devices via CloudKit - **CSV import** with progress tracking and error reporting - **Algorithm consistency** maintained across all platforms ### Quality Gates - **Integration tests pass** with 100% success rate - **Algorithm validation** confirms iOS-Python-Backend consistency - **Performance benchmarks** meet mobile requirements - **Error handling** includes recovery instructions - **User experience** smooth and intuitive ## Risk Mitigation ### Technical Risks - **Network connectivity issues**: Implement robust offline queuing and retry logic - **Sync conflicts**: Use last-write-wins with user notification for important conflicts - **Performance degradation**: Monitor memory usage and implement batching for large datasets - **CloudKit limitations**: Handle CloudKit quotas and rate limits gracefully ### Business Risks - **Algorithm divergence**: Maintain strict validation between platforms - **Data loss**: Implement comprehensive backup and recovery procedures - **User experience**: Provide clear feedback during long operations ## Deliverables Timeline ### Week 3 Deliverables - FastAPI backend with all property endpoints - iOS NetworkManager with authentication and sync - Background sync service implementation - Basic integration testing ### Week 4 Deliverables - CloudKit integration with multi-device sync - CSV import pipeline with progress tracking - Comprehensive integration test suite - Performance optimization and monitoring - Documentation for Phase 2B transition ## Next Phase Preparation Upon completion of Week 3-4, the project will be ready for: - **Phase 2B**: Advanced mobile features (enhanced GPS, offline maps, advanced analytics) - **User acceptance testing** with real Alabama property data - **App Store submission** preparation - **Production deployment** of backend infrastructure The foundation established in Week 1-2 combined with the integration completed in Week 3-4 will provide a robust, scalable platform for the remaining development phases. --- **This roadmap provides a clear, actionable path for the next AI instance to successfully complete Phase 2A Week 3-4 and achieve full iOS-Python backend integration.**